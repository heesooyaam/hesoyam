
                                                _________
                                              || ШАБЛОНЫ ||
                                                ---------

Cинтаксис:

template <class T> (or typename T) // для каждой функции пишем свой, новый шаблон
T Max(T a, T b)
{
    return (a < b ? b : a);
}

_________________________________________________________________________________________
!!!
добавление шаблонов не влияет на скорость работы самой программы,
так как функция компилируется вместе со всей программой и определена на момент работы кода
!!!
__________________________________________________________________________________________

____________________________________________________________________________________________________________________
Чтобы заставить компилятор (инстанцировать) скомпилировать сразу для какого типа данных функцию, можно написать так:

template float  Max(float a, float b);
____________________________________________________________________________________________________________________


_________________________________________________________________________________________________________________________
Чтобы компилятор знал, какой конкретно шаблон мы хотим использовать, при вызове функции можно указать его в скобочках <>:

cout << Max<double> (double a, double b) << endl;
_________________________________________________________________________________________________________________________


_______________________________________________________________________________________________
Если хочется выделить отдельный тип, для ккоторого реализация функции своя, нужно написать это:

template<> char Max(char a, char b)
{
    cout << "не сравнивайте буквы - они обижаются" << endl;
    return '-';
}
_______________________________________________________________________________________________

_________________________________________________________________________________________________________________________________
template<class T1, class T2 = int> - для того, чтобы по дефолту исполльзовать такой тип вместо T2, если не удается его определить
T2 func(T1 a, T2 b)
{
    return a + b;
}
но при вызове func<double, double>(5.1, 5.6) сразу определены все шаблоны,
поэтому дефолное значение использоваться не будет, и она вернет 10.7.
если же просто попросить вернуть его func(5.1, 5.6), то мы получим 10
_________________________________________________________________________________________________________________________________

                                                    |ШАБЛОННЫЕ КЛАССЫ|

Cинтаксис:

template <class K, class T>
class Foo{
    K a;
    T b;
}

template<class T> // переопределение класса(будет исользоваться тогда, когда на вход первым придет int)
class Foo <int, T>{
    int a;
    T b;
}

____________________________________________________________________________________________________________________
Параметр шаблона, не являющийся типом:
--------------------------------------

template<class T, int size>
class TArray
{
    T array_[size] {};
}
int main()
{
    TArray<int, 100> buffer;
    // нельзя написать до этого: int n; cin >> n; TArray<int, n> buffer, так как на этапе компиляции не будет понятно,
    какой размер у массива  
    buffer[10] = 43;
}
______________________________________________________________________________________________________________________
