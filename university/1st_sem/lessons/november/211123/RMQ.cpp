// RMQ - ответы на запросы минимума на интервале
//
// если не меняется массив чисел:
// 1) полный преподсчет(много места нужно)
// 2) частичный преподсчет: будем хранить отрезки не всех длин, а длин, равных степеням двоки
// для массива длины 4 будем хранить: (0, 0), (1, 1), (2, 2), (3, 3), (0, 1), (1, 2), (2, 3), (0, 3)
// тогда каждый запрос - число представимое в виде сумм степеней двоек, на который можно считать за логарифм от длины отрезка, про который спрашивают
// хранить в виде массива sparceTable[idx][len] = min([idx, idx + len])
// --------------
// min(x, x) = x - идемподентность. Если функция обладает этим свойством, то можно улучшить ответ на запрос с O(log n) => O(1)
// --------------
// Идея оптимизации: будем брать минимум из двух отрезков - min([start, start +  2^k], [end - 2 ^ k, end])
// 
// + к условию: массив можно менять
// тогда приведенные выше решения не работают, т.к. пересчитывать таблицу долго
// 1)       [ | | | | | | | ]      2^0

// 2)      [ | | | ] [ | | | ]     2^1

// 3)     [ | ][ | ] [ | ][ | ]    2^2

// 4)   [ ][ ][ ][ ] [ ][ ][ ][ ]  2^3
//                               n(vert) = 2 ^ h